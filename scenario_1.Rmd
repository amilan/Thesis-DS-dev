---
title: "TFM"
author: "Antonio Mil√°n Otero"
date: '`r format(Sys.Date(),"%e de %B %Y")`'
output:
  html_document:
    toc: yes
    number_sections: yes
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_libraries, include=FALSE}
library(knitr)
#library(lubridate)
#library(VIM)
library(stringr)
#library(psych)
library(GEOquery)
library(affy)
# RankProd have a dependency on Rmpfr and this library needs: libmprf-dev
# in ubuntu or derivatives it can be installed with:
# sudo apt-get install libmpfr-dev
library(RankProd)
library(multiClust)
```

# Study of the Transcriptional Function of Cyclin D1 in Leukemia

## Load the datasets

For this study we will make use of the following datasets available in the Gene Expression Omnibus (GEO) repository:

* GSE21452
* GSE25848

The first step will be the loading of the datasets. For that purpose we will use the bioconductor package GEOquery. This package will allow us to load the dataset directly from the filesystem or to download it directly using the same command.
In my case, I have already downloade the dataset, and I will use it from the filesystem.

```{r, echo=FALSE}
gse_21452 <- getGEO(filename="data/GSE21452_series_matrix.txt.gz")
# In case you don't have it donwloaded, this dataset can be obtained with the command:
# gse21452 <- getGEO("GSE21452", GSEMatrix=TRUE)
# the only difference to keep in mind is that the second command will create a list of ExpressionSet, and therefore, the treatement of that class will be slidely different.
```

We explore our loaded data now.

```{r}
show(gse_21452)
```

```{r}
head(pData(phenoData(gse_21452)))
```

```{r}
# summary(pData(phenoData(gse_21452)))
head(exprs(gse_21452),1)
```

Now we can load the data regarding DDR, following the same procedure as before.

```{r}
gse_25848 <- getGEO(filename="data/GSE25848_series_matrix.txt.gz")
```

```{r}
show(gse_25848)
```

```{r}
head(pData(phenoData(gse_25848)))
```

```{r}
# summary(pData(phenoData(gse_21452)))
head(exprs(gse_25848))
```

First thing to notice from this data is that we have many NA values.
In our study we are going to make a comparison between the expressed genes in both datasets, and we can assume that if no data is available for that gene, it is not expressed and can be removed.

Let's see how many NA do we have.

```{r}
sapply(data.frame(exprs(gse_21452)), function(x)(sum(is.na(x))))
```

```{r}
sapply(data.frame(exprs(gse_25848)), function(x)(sum(is.na(x))))
```

```{r}
length(data.frame(exprs(gse_25848))$GSM634846) - 32443
```

We have 32443 out of 48803 genes without any data, in other words, we have only 16360 genes with an expression value.

```{r}
# Remove the NA entries keeping the ExpressionSet object
idx_to_rmv <- which(apply(exprs(gse_25848), 1, function(x) any ( is.na(x))))
gse_25848 <- gse_25848[-idx_to_rmv,]
```

## Data Normalization

Before running any normalization process, it is worth to have a look to the process that has been followed to generate the datasets.

```{r}
head(gse_25848$data_processing, 1)
```

```{r}
head(gse_21452$data_processing.1, 1)
```

```{r}
# TODO: As we have the p values for the expressionSet of each dataset, 
#       I'm not sure about the necessity of more normalization.
#       Maybe log2 or scale the data ... ?
# update:
#       Seems that the GSE21452 series have been log2 transformed.
#       Let's log2 transform the data from the GSE25848.
#       But I'm afraid that we should get the raw data and apply the
#       same normalization process to both datasets.
# update 2019-05-14:
#       Not sure if this normalization is correct. Is it done by column,by row or taking the whole matrix?
# update:
#       To scale properly we need to transponse the matrix.
```

Let's normalize the values of both datasets.

```{r}
# Instead of normalize it here we can also apply this normalization just before merging the datasets.
# (as we are going to select the top ranked genes from each individual dataset, first)
#exprs(gse_21452) <- t(scale(t(exprs(gse_21452))))
#exprs(gse_25848) <- t(scale(t(exprs(gse_25848))))
```

## Linear Model for Microarray Analysis

Not necessary at this moment as we are going to select the Genes using the package multiClust.

## Intersection

In order to do the intersection of both datasets we need to rank the most expresses genes and keep the top ones.
For that purspose we can use the multiClust package.

```{r}
WriteMatrixToFile(tmpMatrix=exprs(gse_21452), tmpFileName="GSE21452.Norm.expression.txt",
    blnRowNames=TRUE, blnColNames=TRUE)
    
WriteMatrixToFile(tmpMatrix=exprs(gse_25848), tmpFileName="GSE21452.Norm.expression.txt",
    blnRowNames=TRUE, blnColNames=TRUE)
```

(I don't like to use files in between ... but it is the only way right now)

```{r}
gse_21_expr_file <- system.file("extdata", "GSE21452.Norm.expression.txt", package = "multiClust")

gse_25_expr_file <- system.file("extdata", "GSE21452.Norm.expression.txt", package = "multiClust")

```


```{r}
# Call probe_ranking function
# Select for 10000 probes
# Choose genes using the SD_Rank method
ranked.exprs_gse21 <- probe_ranking(input=gse_21_expr_file,
    probe_number=10000,
    probe_num_selection="Fixed_Probe_Num",
    data.exp=exprs(gse_21452), 
    #method="CV_Rank")
    method="SD_Rank")

ranked.exprs_gse25 <- probe_ranking(input=gse_25_expr_file,
    probe_number=10000,
    probe_num_selection="Fixed_Probe_Num",
    data.exp=exprs(gse_25848), 
    #method="CV_Rank")
    method="SD_Rank")
```

Let's have a look to the generated selection.

```{r}
head(ranked.exprs_gse21)
head(ranked.exprs_gse25)
```


The next step is to keep only the expressed genes appearing in both selection. As we can notice, genes have different names in each dataset, therefore, we will need to get the gene name from the featuredata.

Using rowname and featuredata/data/id, FeatureData/data/Entrez_gene_id

```{r}
# Just checking that cyclin d1 is in the selection.
ranked.exprs_gse21["208712_at",]
#exprs(gse_21452)["208712_at",]
#gse_21_norm["208711_s_at",]
ranked.exprs_gse21["208711_s_at",] # with 3000 is not selected.
#data.frame(exprs(gse_21452)["208711_s_at",])
ranked.exprs_gse25["ILMN_1688480",]
```

```{r}
ranked.exprs_gse25["ILMN_1688480",]
#gse_25848_clean["ILMN_1688480",]
data.frame(exprs(gse_25848["ILMN_1688480",]))
```

```{r}
# Indexes for the genes to keep
gse_21_idx <- match(rownames(data.frame(ranked.exprs_gse21)),
                    pData(featureData(gse_21452))$ID)
gse_25_idx <- match(rownames(data.frame(ranked.exprs_gse25)),
                    pData(featureData(gse_25848))$ID)
```

```{r}
# Get the final ExpressionSet with only the ranked genes
ranked_gse_21 <- gse_21452[gse_21_idx,]
ranked_gse_25 <- gse_25848[gse_25_idx,]
```

```{r}

# Get the Entrez_Gene_ID used to match genes in both datasets.
# I'm using Entrez_Gene_ID because Symbols or GB_ACC are not
# suitable for a match as that data is quite dirty.
gse_21_ids <- pData(featureData(ranked_gse_21))$ENTREZ_GENE_ID
gse_25_ids <- pData(featureData(ranked_gse_25))$Entrez_Gene_ID

#gse_21_ids <- pData(featureData(gse_21452))$`Gene Symbol`[gse_21_idx]
#gse_25_ids <- pData(featureData(gse_25848))$Symbol[gse_25_idx]

# There are genes without ID!!!! Let's use symbols!!! (same problem with symbols)
##head(gse_21_ids)
##head(gse_25_ids)

### GB_ACC
#gse_21_ids <- pData(featureData(ranked_gse_21))$GB_ACC
#gse_25_ids <- pData(featureData(ranked_gse_25))$GB_ACC

# Again ... same problems with GB_ACC

head(gse_21_ids)
head(gse_25_ids)
```

```{r}
# Used to clean GB_ACC
# TODO: To be removed

# Remove the . on gse_25_ids

#get_first_item <- function(items){
#  first_item <- unlist(strsplit(items, "[.]"))[1]
#  return(first_item)
#}

#gse_25_ids <- unlist(lapply(gse_25_ids, get_first_item))
#length(gse_21_ids)
#length(gse_25_ids)

#sapply(data.frame(gse_21_ids), function(x)(sum(is.na(x))))
#sapply(data.frame(gse_25_ids), function(x)(sum(is.na(x))))

#gse_25_ids <- na.omit(gse_25_ids)
```

Before merging, we need to remove the multiple entrez_gene_id entries and keep only the first one.

```{r}
#unlist(strsplit(gse_21_ids[3], "[ ///]"))[1]

get_first_item <- function(items){
  first_item <- unlist(strsplit(items, "[ ///]"))[1]
  return(first_item)
}
#get_first_item(gse_21_ids)

#strsplit(gse_21_ids, '^\w+.\w+')
gse_21_ids <- as.numeric(unlist(lapply(gse_21_ids, get_first_item)))
#symbols_gse25 <- unlist(lapply(gse_25_ids, get_first_item))
```

Now that we have cleaned the ids, let's perform the match.

```{r}
# Get the indexes from gse_25 that appears in gse_21
matched_idx <- match(gse_21_ids, gse_25_ids)

# Keep only the matched elements in gse_21
idx_to_keep <- is.na(matched_idx)
common_gse_21 <- ranked_gse_21[!idx_to_keep]

# Keep only the matched elements gse_25
common_gse_25 <- ranked_gse_25[matched_idx]

# Remove NA
idx_to_rmv <- which(apply(pData(featureData(common_gse_25)), 1, function(x) any ( is.na(x))))
common_gse_25 <- common_gse_25[-idx_to_rmv,]
```

As we have removed the NAs in gse_25, we need to match again.

```{r}
gse_21_ids_2 <- pData(featureData(common_gse_21))$ENTREZ_GENE_ID
gse_25_ids_2 <- pData(featureData(common_gse_25))$Entrez_Gene_ID
gse_21_ids_2 <- as.numeric(unlist(lapply(gse_21_ids_2, get_first_item)))

matched_idx_2 <- match(gse_25_ids_2, gse_21_ids_2)
common_gse_21 <- common_gse_21[matched_idx_2]
```

Just to be sure, let's check the first values of the entrez_gene_ids for both datasets.

```{r}
head(pData(featureData(common_gse_21))$ENTREZ_GENE_ID)
head(pData(featureData(common_gse_25))$Entrez_Gene_ID)
```

```{r}
# Now that we are going to merge the datasets, this normalization is needed.
exprs(common_gse_21) <- t(scale(t(exprs(common_gse_21))))
exprs(common_gse_25) <- t(scale(t(exprs(common_gse_25))))
```

Let's merge the datasets by adding the columns of common_gse_25 to common_gse_21

```{r}
#common_gse <- common_gse_21
common_gse <- cbind(exprs(common_gse_21), exprs(common_gse_25))
```

## RankProd Analysis

For this step we will use the package RankProd from Bioconductor.
First, we need to prepare the two groups.

```{r}
ncol(exprs(common_gse_21))
c1 <- rep(0, ncol(exprs(common_gse_21)))
c2 <- rep(1, ncol(exprs(common_gse_25)))
cl <- c(c1, c2)
cl
```

```{r}
# We can also use: RP.adv.out <- RP.advance()

RP.out <- RankProducts(common_gse, cl,
                       logged=TRUE, rand=42,
                       gene.names=rownames(common_gse),
                       plot = TRUE)
```


```{r}
# No significant values using a cutoff on pfp
#tables <- topGene(RP.out, cutoff = 0.05, method = "pfp", gene.names=rownames(common_gse))
tables <- topGene(RP.out, cutoff = 0.05, method = "pval", gene.names=rownames(common_gse))
```

```{r}
head(tables$Table1)
#tables$Table1
```

```{r}
head(tables$Table2)
#tables$Table2
```

## Feature Selection

## GSEA